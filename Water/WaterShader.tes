#version 400 core

layout (quads, equal_spacing, ccw) in;

uniform mat4 MVP;

in vec3 position_tcs[];
in vec2 uv_tcs[];
in vec3 eye_tcs[];
in vec3 light_tcs[];
in vec3 normal_tcs[];         
out vec3 position_tes;
out vec2 uv_tes;
out vec3 eye_tes;
out vec3 light_tes;
out vec3 normal_tes;         

void main() {
    float u = gl_TessCoord.x;
    float v = gl_TessCoord.y;

    // Bilinear interpolation of vertex positions
    vec3 p0 = position_tcs[0];
    vec3 p1 = position_tcs[1];
    vec3 p2 = position_tcs[2];
    vec3 p3 = position_tcs[3];
    position_tes = mix(mix(p0, p1, u), mix(p3, p2, u), v);

    vec2 uv0 = uv_tcs[0];
    vec2 uv1 = uv_tcs[1];
    vec2 uv2 = uv_tcs[2];
    vec2 uv3 = uv_tcs[3];
    uv_tes = mix(mix(uv0, uv1, u), mix(uv3, uv2, u), v);

    vec3 eye0 = eye_tcs[0];
    vec3 eye1 = eye_tcs[1];
    vec3 eye2 = eye_tcs[2];
    vec3 eye3 = eye_tcs[3];
    eye_tes = mix(mix(eye0, eye1, u), mix(eye3, eye2, u), v);

    vec3 light0 = light_tcs[0];
    vec3 light1 = light_tcs[1];
    vec3 light2 = light_tcs[2];
    vec3 light3 = light_tcs[3];
    light_tes = mix(mix(light0, light1, u), mix(light3, light2, u), v);

    vec3 n0 = normal_tcs[0];
    vec3 n1 = normal_tcs[1];
    vec3 n2 = normal_tcs[2];
    vec3 n3 = normal_tcs[3];
    normal_tes = mix(mix(n0, n1, u), mix(n3, n2, u), v);

    // MVP application (optional here â€” GS can override)
    gl_Position = MVP * vec4(position_tes, 1.0);
}
